bolha :: Ord a => [a] -> [a]
bolha [] = []
bolha lst = bolhaOrd lst (length lst)

bolhaOrd :: Ord a => [a] -> Int -> [a]
bolhaOrd lst 0 = lst
bolhaOrd lst n = do
    if count /= 0 then
        (bolhaOrd body (n-1)) ++ last
        else list
        where
            (list, count) = troca (lst, 0)
            last = splitLast list
            body = splitBody list
            
splitBody :: [a] -> [a]
splitBody lst = take (length lst - 1) lst

splitLast :: [a] -> [a]
splitLast lst = drop (length lst - 1) lst

troca :: Ord a => ([a], Int) -> ([a], Int)
troca ([x], n) = ([x], n)
troca ((x:y:zs), n) = if x < y then
  addInitList (troca ((x:zs), n+1)) y else
  addInitList (troca ((y:zs), n)) x
    where
      addInitList (list, n) a = (a:list, n)
--EX4
somat :: Int -> Int
somat n = foldr1 (+) (map (^3) [0..n])

produt :: Int -> Int
produt n = foldr1 (*) (map (^3) [1..n])

verifica::(Int, Int)->Int
verifica (x, y) = if y>x then x+y else 0

pares1::[(Int, Int)]->[Int]
pares1 lst = filter (/=0) (map(verifica) lst)

pares2::[(Int, Int)]->[Int]
pares2 lst =  (map(verifica2) lst)

verifica2::(Int, Int)->Int
verifica2 (x, y) = x^y

totaliza1::[(Int, Int)]->Int
totaliza1 lst = foldr1 (+) (map(verifica3) lst)

verifica3::(Int, Int)->Int
verifica3 (x, y) = if y>x then x*y else 0

totaliza2::[(Int, Int)]->Int
totaliza2 lst = foldr1 (+) (map(verifica3) lst)

triplas1 :: [(Int,Int,Int)] -> [Int]
triplas1 lst = filter (/=0) (map(verifica4) lst)

verifica4::(Int,Int,Int)->Int
verifica4 (x,y,z) = if x>y && y<z then x*y*z else 0

triplas2 :: [(Int,Int,Int)] -> [Int]
triplas2 lst = filter (/=0) (map(verifica5) lst)

verifica5::(Int,Int,Int)->Int
verifica5 (x,y,z) = if mod (x+y+z) 2 /= 0 then x+y+z else 0

--Ex5


--Ex6
data ArvoreBinInt = Nulo | No Int ArvoreBinInt ArvoreBinInt deriving (Show,Eq)

arvEx :: ArvoreBinInt
arvEx = (No 7 (No 3 (No 1 Nulo Nulo) (No 6 (No 4 Nulo Nulo) Nulo)) (No 10 Nulo (No 14 Nulo Nulo)))


somapares :: ArvoreBinInt -> (Int,Int)
somapares lst = (gerapar (folhas lst),gerapar (internos lst))


internos :: ArvoreBinInt -> [Int]
internos Nulo = []
internos (No _ Nulo Nulo) = []
internos (No x esq dir) = (x : internos esq) ++ internos dir

gerapar :: [Int] -> Int
gerapar lst = sum [x | x<-lst, even x]

folhas :: ArvoreBinInt -> [Int]
folhas Nulo = []
folhas (No x Nulo Nulo) = [x]
folhas (No x esq dir) = (folhas esq) ++ folhas dir

--EX7
