--EX1
splitBody :: [a] -> [a]
splitBody lst = take (length lst - 1) lst

splitLast :: [a] -> [a]
splitLast lst = drop (length lst - 1) lst
  
bolha :: Ord a => [a] -> [a]
bolha [] = []
bolha lst = bolhaOrd lst (length lst)

bolhaOrd :: Ord a => [a] -> Int -> [a]
bolhaOrd lst n = do
    if count /= 0 then
        (bolhaOrd body (count)) ++ last
        else list
        where
            (list, count) = troca (lst, 0)
            last = splitLast list
            body = splitBody list

troca :: Ord a => ([a], Int) -> ([a], Int)
troca ([x], n) = ([x], n)
troca ((x:y:zs), n) = if x < y then
  addInitList (troca ((x:zs), n+1)) y else
  addInitList (troca ((y:zs), n)) x
    where
      addInitList (list, n) a = (a:list, n)
--EX4
somat :: Int -> Int
somat n = foldr1 (+) (map (^3) [0..n])

produt :: Int -> Int
produt n = foldr1 (*) (map (^3) [1..n])

verifica::(Int, Int)->Int
verifica (x, y) = if y>x then x+y else 0

pares1::[(Int, Int)]->[Int]
pares1 lst = filter (/=0) (map(verifica) lst)

pares2::[(Int, Int)]->[Int]
pares2 lst =  (map(verifica2) lst)

verifica2::(Int, Int)->Int
verifica2 (x, y) = x^y

totaliza1::[(Int, Int)]->Int
totaliza1 lst = foldr1 (+) (map(verifica3) lst)

verifica3::(Int, Int)->Int
verifica3 (x, y) = if y>x then x*y else 0

totaliza2::[(Int, Int)]->Int
totaliza2 lst = foldr1 (+) (map(verifica3) lst)

triplas1 :: [(Int,Int,Int)] -> [Int]
triplas1 lst = filter (/=0) (map(verifica4) lst)

verifica4::(Int,Int,Int)->Int
verifica4 (x,y,z) = if x>y && y<z then x*y*z else 0

triplas2 :: [(Int,Int,Int)] -> [Int]
triplas2 lst = filter (/=0) (map(verifica5) lst)

verifica5::(Int,Int,Int)->Int
verifica5 (x,y,z) = if mod (x+y+z) 2 /= 0 then x+y+z else 0

--Ex5


--Ex6
data ArvoreBinInt = Nulo | No Int ArvoreBinInt ArvoreBinInt deriving (Show,Eq)

arvEx :: ArvoreBinInt
arvEx = (No 7 (No 3 (No 1 Nulo Nulo) (No 6 (No 4 Nulo Nulo) Nulo)) (No 10 Nulo (No 14 Nulo Nulo)))


somapares :: ArvoreBinInt -> (Int,Int)
somapares lst = (gerapar (folhas lst),gerapar (internos lst))


internos :: ArvoreBinInt -> [Int]
internos Nulo = []
internos (No _ Nulo Nulo) = []
internos (No x esq dir) = (x : internos esq) ++ internos dir

gerapar :: [Int] -> Int
gerapar lst = sum [x | x<-lst, even x]

folhas :: ArvoreBinInt -> [Int]
folhas Nulo = []
folhas (No x Nulo Nulo) = [x]
folhas (No x esq dir) = (folhas esq) ++ folhas dir

--EX7
data Pagamento = Dinheiro | Cartao | Boleto deriving (Show, Ord, Eq)

data Vol = Baixo | Medio | Alto
 deriving (Show, Ord, Eq)

data Cliente = Clnt String Int Int Pagamento Vol deriving (Show , Ord , Eq)


lista :: [Cliente]
lista = [
    (Clnt "Alexandre" 1 12 (Dinheiro) (Baixo)),
    (Clnt "Breno" 2 12 (Dinheiro) (Baixo)),
    (Clnt "Caio" 3 12 (Dinheiro) (Baixo)),
    (Clnt "Daniel" 4 11 (Dinheiro) (Medio)),
    (Clnt "Eduardo" 5 11 (Dinheiro) (Medio)),
    (Clnt "Felipe" 6 11 (Dinheiro) (Medio)),
    (Clnt "Guilherme" 7 10 (Dinheiro) (Alto)),
    (Clnt "Henrique" 8 10 (Dinheiro) (Alto)),
    (Clnt "Isaac" 9 10 (Dinheiro) (Alto)),
    (Clnt "João" 10 9 (Cartao) (Baixo)),
    (Clnt "Kaique" 11 9 (Cartao) (Baixo)),
    (Clnt "Leonardo" 12 9 (Cartao) (Baixo)),
    (Clnt "Murilo" 13 8 (Cartao) (Medio)),
    (Clnt "Nathan" 14 8 (Cartao) (Medio)),
    (Clnt "Otávio" 15 8 (Cartao) (Medio)),
    (Clnt "Pietro" 16 7 (Cartao) (Alto)),
    (Clnt "Rafael" 17 7 (Cartao) (Alto)),
    (Clnt "Samuel" 18 7 (Cartao) (Alto)),
    (Clnt "Thiago" 19 6 (Boleto) (Baixo)),
    (Clnt "Vitor" 20 6 (Boleto) (Baixo)),
    (Clnt "Yago" 21 6 (Boleto) (Baixo)),
    (Clnt "Enzo" 22 5 (Boleto) (Medio)),
    (Clnt "Pedro" 23 5 (Boleto) (Medio)),
    (Clnt "Arthur" 24 5 (Boleto) (Medio)),
    (Clnt "Gina" 25 4 (Boleto) (Alto)),
    (Clnt "Mirella" 26 4 (Boleto) (Alto)),
    (Clnt "Elisa" 27 4 (Boleto) (Alto))
    ]

  
msort :: [Cliente]->[Cliente]
msort [] = []
msort [x] = [x]
msort xs = merge (msort ys) (msort zs)
 where
  (ys,zs) = divide xs

divide ::[Cliente] -> ([Cliente],[Cliente])
divide [] = ([],[])
divide [x] = ([x],[])
divide (x:y:t)  = ((x:xs),(y:ys))
 where
  (xs,ys) = divide t

merge :: [Cliente]->[Cliente]->[Cliente]
merge xs [] = xs
merge [] xs = xs
merge (x:xs) (y:ys)
 | compara x y = x:(merge xs (y:ys))
 | otherwise = y: (merge (x:xs) ys)
 where 
  compara (Clnt _ _ _ _ (Medio)) (Clnt _ _ _ _ (Alto)) = True
  compara (Clnt _ _ _ _ (Baixo)) (Clnt _ _ _ _ (Medio)) = True
  compara (Clnt _ _ _ _ (Baixo)) (Clnt _ _ _ _ (Alto)) = True
  compara (Clnt _ _ _ (Dinheiro) _) (Clnt _ _ _ (Cartao) _) = True
  compara (Clnt _ _ _ (Dinheiro) _) (Clnt _ _ _ (Boleto) _) = True
  compara (Clnt _ _ _ (Cartao) _) (Clnt _ _ _ (Boleto) _) = True
  compara _ _ = False
